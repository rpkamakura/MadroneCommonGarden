} else {
Test_df[,c] <- Test[,RandVar] #Random Variable
}
}
}
if (dvar==3 && (length(Test_df[1,]) > 4)){ #to deal with the rescaling that you have to do
toRescale <- Test_df[,!(names(Test_df) %in% c("dep_dat", "rand1_dat", "ntrials"))]
numcols <- c(1:length(toRescale[1,]))[sapply(toRescale[1,], is.numeric)]
toRescale[,numcols] <- scale(toRescale[,numcols])
Test_df[,!(names(Test_df) %in% c("dep_dat", "rand1_dat", "ntrials"))] <- toRescale
}
predictions <- res1_obj %>% predict(Test_df, type = "response")  #predict(res1_obj, Test_df)
if (dvar == 1){
#mae_v <- RMSE(as.vector(predictions), Test[,grp_col])
mae_v <- MAE(as.vector(predictions), Test[,grp_col])
} else {
#mae_v <- RMSE(Test[,grp_col],as.vector(predictions))
mae_v <- MAE(as.vector(predictions), Test[,grp_col])
}
} else { ##for everything except the Phenology ones
types <- functype[indep_func_ind] #get the function types
##Add the names of/number of independent variables to the corresponding lists
reg_res1 <- MultReg2(Train, indep_ind, grp_col, types, RandVar, family = f)
res1_df <- reg_res1[[1]]
res1_obj <- reg_res1[[2]]
##should be able to use the function predict, but you have to create the right format of df
Test_df <- as.data.frame(matrix(0, nrow = length(Test[,1]), ncol = length(res1_df)))
names(Test_df) <- names(res1_df)
sq <- FALSE
test_ind <- 1
for (c in 1:length(res1_df)){
if (c == 1){
Test_df[,c] <- Test[,grp_col] #Dependent Variable
} else if (c == length(res1_df)) {
Test_df[,c] <- Test[,RandVar] #Random Variable
} else if (types[test_ind] == "E" || types[test_ind] == "L") {
Test_df[,c] <- Test[,indep_ind[(c-1)]] #Independent Variables
test_ind <- test_ind + 1
} else { #not at the end and not a linear term (so the quadratic terms)
if (sq) { #if it is the square of a value
Test_df[,c] <- (Test[,indep_ind[(test_ind)]])^2 #Independent Variable Squared
sq <- FALSE
if (test_ind < length(types)){
test_ind <- test_ind + 1
}
} else {
Test_df[,c] <- Test[,indep_ind[(test_ind)]] #Independent Variables
sq <- TRUE
}
}
}
predictions <- predict(res1_obj, Test_df)
mae_v <- MAE(as.vector(predictions), Test[,grp_col])
#mae_v <- RMSE(as.vector(predictions), Test[,grp_col])
} #end of gr, dbk, mort if statement
reg_mae <- append(reg_mae, mae_v)
} #End of regression for loop
mae_vals[[k]] <- reg_mae
} ## end of cross-val loop
if (grp==1){ ###############################################
#Overall Model Matrix
nrowsOverall = length(mae_vals[[1]])
o_cols <- c("Group", "Dep", "Indep", print(paste("MAE", 1:k, sep="")))
overal_mod <- as.data.frame(matrix(NA, nrow = nrowsOverall, ncol = length(o_cols)))
colnames(overal_mod) <- o_cols
overal_mod[,1] <- rep(grp_nm, length(nrowsOverall))
overal_mod[,2] <- rep(d_vars[dvar], nrowsOverall)
overal_mod[,3] <- pert_regs[, 3]
#To assign the error columns in a visible way/easy to summarize
for (error_col in 1:k){
overal_mod[,(error_col+3)] <- mae_vals[[error_col]]
}
} else { #depending on which Phenological Var you're on
nrowsOverall = length(pert_regs[,1]) + length(overal_mod[,1])
nrows_nw <- length(pert_regs[,1])
oldOveralmat = overal_mod
o_cols <- c("Group", "Dep", "Indep", print(paste("MAE", 1:k, sep="")))
overal_mod <- matrix(NA, nrow = nrowsOverall, ncol = length(o_cols))
colnames(overal_mod) <- o_cols
overal_mod[,1] <- append(oldOveralmat[,1], rep(grp_nm, nrows_nw))
overal_mod[,2] <- append(oldOveralmat[,2], rep(d_vars[dvar], nrows_nw))
overal_mod[,3] <- append(oldOveralmat[,3], pert_regs[, 3])
#To assign the error columns in a visible way/easy to summarize
for (error_col in 1:k){
overal_mod[,(error_col+3)] <- append(oldOveralmat[,(error_col+3)], mae_vals[[error_col]])
}
} #depending on which group loop you're on
} ## end of site/phenological loop
write.csv(overal_mod, print(paste("../05ProcessedDataOutputs/04CrossVal", d_vars[dvar], "MAE.csv", sep="")))
}
###Skeleton cross-validation - using caret package
##Phenology first to test it - it is simpler
###you want to try to stratify by family though (or at least by Source)
d_vars <- c("Phenology", "TotGrowth", "PercDead")
Phen_types <- c("Bud.Swollen", "Bud.Elongating", "Leaves.emerging")
dvar <- 0 #just to keep track of whcih one you're on
k_fold <- 5
for (DepVar in regdata) { #For each response variable
dvar <- dvar + 1
if (dvar ==1){
#just for right now since you should already have phenology
##how many groups (variables) there are
n <- 3
##set up the dataframe and grouping variable
df <- PhenData
df <- df[complete.cases(df), ] #get rid of the NAs basically
df_class <- df$Name
RandVar <- match("Block", colnames(df)) #random variable
##Create training and test datasets
folds <- createFolds(df_class, list = FALSE, k = k_fold)
paramlist <- c("Ecoregion", "Lat", "Long", "Elev", "eFFP",
"MSP", "Slope", "Aspect", "DD.5.sp")
#next #just for now
} else if (dvar == 2 || dvar == 3){
n <- 4 #the number of sites for Growth Rate, Dieback, and Mortality
paramlist <- c("Ecoregion", "Dist", "Slope", "Aspect", "ElevDist", "eFFP", "MSP", "DD.5.sp")
}
#######################################################################
for (grp in 1:n){ ##the groupings, either by site or by phen for phenology
##MAE list
mae_vals <- c()
if (dvar == 1) { ##Phenology
grps <- c("Bud.Swollen", "Bud.Elongating", "Leaves.emerging")
grp_col <- match(grps[grp], names(PhenData))
grp_nm <- Phen_types[grp]
pert_regs <- DepVar[DepVar$Phen == grp_nm,]
ntrials = NA
f = "linear"
} else if (dvar == 2 ){ #growth rate
grp_nm <- names(GrDbkData)[grp]
df <- GrDbkData[[grp]]
df <- df[complete.cases(df), ] #get rid of the NAs basically
df_class <- df$Source
binomial = FALSE
folds <- createFolds(df_class, list = FALSE, k = k_fold)
if (dvar == 2){
grp_col <- match("TotGrowth", colnames(df))
RandVar <- match("Block", colnames(df)) #random variable
f = "linear"
# } else {
#
#   grp_col <- match("AmntDieback", colnames(df))
#   RandVar <- match("Block", colnames(df)) #random variable
#   f = "zeroinfl"
#
}
pert_regs <- DepVar[(DepVar$Site == grp_nm),] #find the regressions for that site
} else if (dvar == 3){ #Mortality
grp_nm <- names(MortData)[grp]
df <- MortData[[grp]]
df <- df[complete.cases(df), ] #get rid of the NAs basically
df_class <- df$Source
binomial = TRUE
folds <- createFolds(df_class, list = FALSE, k = k_fold)
grp_col <- match("PercDead", colnames(df))
RandVar <- match("Block", colnames(df)) #random variable
ntrials <- match("Total", colnames(df))
pert_regs <- DepVar[(DepVar$Site == grp_nm),] #find the regressions for that site
f = "binomial"
} ## end of training dataset deliniation loop
######################################################################
for (k in 1:k_fold){
##Initialize parameter lists
Train <- df[(folds!=k),]
Test  <- df[(folds==k),]
reg_mae <- c()
for (reg in 1:length(pert_regs[,1])){ #For each regression
indep_vars <- unlist(strsplit(pert_regs$IndepVars[reg], "_")) #split the variables up
indep_ind <- match(indep_vars, colnames(df)) #get the indexes for the independent variables
indep_func_ind <- match(indep_vars, paramlist) #get the index for their function types
if (dvar ==1|| dvar==3){ ##for the phenology data
reg_res1 <- MultReg3(Train, indep_ind, grp_col, RandVar, family = f, priorw = ntrials)
#reg_results
res1_df <- reg_res1[[1]]
res1_obj <- reg_res1[[2]]
##should be able to use the function predict, but you have to create the right format of df
Test_df <- as.data.frame(matrix(0, nrow = length(Test[,1]), ncol = length(res1_df)))
names(Test_df) <- names(res1_df)
if (dvar == 3){
for (c in 1:length(res1_df)){
if (c == 1){
Test_df[,c] <- Test[,grp_col] #Dependent Variable
} else if (c != length (res1_df)){
if( c == (length(res1_df)-1)){
Test_df[,c] <- Test[,RandVar] #Random Variable
} else {
Test_df[,c] <- Test[,indep_ind[(c-1)]] #Independent Variables
}
} else {
Test_df[,c] <- Test[,ntrials]
}
}
} else {
for (c in 1:length(res1_df)){
if (c == 1){
Test_df[,c] <- Test[,grp_col] #Dependent Variable
} else if (c != length (res1_df)){
Test_df[,c] <- Test[,indep_ind[(c-1)]] #Independent Variables
} else {
Test_df[,c] <- Test[,RandVar] #Random Variable
}
}
}
if (dvar==3 && (length(Test_df[1,]) > 4)){ #to deal with the rescaling that you have to do
toRescale <- Test_df[,!(names(Test_df) %in% c("dep_dat", "rand1_dat", "ntrials"))]
numcols <- c(1:length(toRescale[1,]))[sapply(toRescale[1,], is.numeric)]
toRescale[,numcols] <- scale(toRescale[,numcols])
Test_df[,!(names(Test_df) %in% c("dep_dat", "rand1_dat", "ntrials"))] <- toRescale
}
predictions <- res1_obj %>% predict(Test_df, type = "response")  #predict(res1_obj, Test_df)
if (dvar == 1){
#mae_v <- RMSE(as.vector(predictions), Test[,grp_col])
mae_v <- MAE(as.vector(predictions), Test[,grp_col])
} else {
#mae_v <- RMSE(Test[,grp_col],as.vector(predictions))
mae_v <- MAE(as.vector(predictions), Test[,grp_col])
}
} else { ##for everything except the Phenology ones
types <- functype[indep_func_ind] #get the function types
##Add the names of/number of independent variables to the corresponding lists
reg_res1 <- MultReg2(Train, indep_ind, grp_col, types, RandVar, family = f)
res1_df <- reg_res1[[1]]
res1_obj <- reg_res1[[2]]
##should be able to use the function predict, but you have to create the right format of df
Test_df <- as.data.frame(matrix(0, nrow = length(Test[,1]), ncol = length(res1_df)))
names(Test_df) <- names(res1_df)
sq <- FALSE
test_ind <- 1
for (c in 1:length(res1_df)){
if (c == 1){
Test_df[,c] <- Test[,grp_col] #Dependent Variable
} else if (c == length(res1_df)) {
Test_df[,c] <- Test[,RandVar] #Random Variable
} else if (types[test_ind] == "E" || types[test_ind] == "L") {
Test_df[,c] <- Test[,indep_ind[(c-1)]] #Independent Variables
test_ind <- test_ind + 1
} else { #not at the end and not a linear term (so the quadratic terms)
if (sq) { #if it is the square of a value
Test_df[,c] <- (Test[,indep_ind[(test_ind)]])^2 #Independent Variable Squared
sq <- FALSE
if (test_ind < length(types)){
test_ind <- test_ind + 1
}
} else {
Test_df[,c] <- Test[,indep_ind[(test_ind)]] #Independent Variables
sq <- TRUE
}
}
}
predictions <- predict(res1_obj, Test_df)
mae_v <- MAE(as.vector(predictions), Test[,grp_col])
#mae_v <- RMSE(as.vector(predictions), Test[,grp_col])
} #end of gr, dbk, mort if statement
reg_mae <- append(reg_mae, mae_v)
} #End of regression for loop
mae_vals[[k]] <- reg_mae
} ## end of cross-val loop
if (grp==1){ ###############################################
#Overall Model Matrix
nrowsOverall = length(mae_vals[[1]])
o_cols <- c("Group", "Dep", "Indep", print(paste("MAE", 1:k, sep="")))
overal_mod <- as.data.frame(matrix(NA, nrow = nrowsOverall, ncol = length(o_cols)))
colnames(overal_mod) <- o_cols
overal_mod[,1] <- rep(grp_nm, length(nrowsOverall))
overal_mod[,2] <- rep(d_vars[dvar], nrowsOverall)
overal_mod[,3] <- pert_regs[, 3]
#To assign the error columns in a visible way/easy to summarize
for (error_col in 1:k){
overal_mod[,(error_col+3)] <- mae_vals[[error_col]]
}
} else { #depending on which Phenological Var you're on
nrowsOverall = length(pert_regs[,1]) + length(overal_mod[,1])
nrows_nw <- length(pert_regs[,1])
oldOveralmat = overal_mod
o_cols <- c("Group", "Dep", "Indep", print(paste("MAE", 1:k, sep="")))
overal_mod <- matrix(NA, nrow = nrowsOverall, ncol = length(o_cols))
colnames(overal_mod) <- o_cols
overal_mod[,1] <- append(oldOveralmat[,1], rep(grp_nm, nrows_nw))
overal_mod[,2] <- append(oldOveralmat[,2], rep(d_vars[dvar], nrows_nw))
overal_mod[,3] <- append(oldOveralmat[,3], pert_regs[, 3])
#To assign the error columns in a visible way/easy to summarize
for (error_col in 1:k){
overal_mod[,(error_col+3)] <- append(oldOveralmat[,(error_col+3)], mae_vals[[error_col]])
}
} #depending on which group loop you're on
} ## end of site/phenological loop
write.csv(overal_mod, print(paste("../05ProcessedDataOutputs/04CrossVal/", d_vars[dvar], "MAE.csv", sep="")))
}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(plyr)
library(dplyr)
library(survival)
library(nlme)
library(psychometric)
library(MASS)
library(gnm)
library(MuMIn)
#pull in the functions we need to get growth/mortality/dieback and for the
#regressions
source("../04ProcessingCode/BackgroundFunctions/01AnalysisFunctions_GRMort.R")
source("../04ProcessingCode/BackgroundFunctions/02RegressionFuncs.R")
options(stringsAsFactors = FALSE)
#Names
years <- c(12, 13, 14, 15)
#years <- c(14, 15)
sites <- c("PuyallupValley", "PuyallupHill", "Starker", "Sprague")
#Ecoregion data
ecoregdat <- read.csv("../01ExampleRawData/02LocationData/EcoregionData.csv")
ecoregions <- unique(ecoregdat$EcoregionShort)
#Sources
sources <- unique(ecoregdat$Source)
##Get the full data files
pertfiles <- list("../03ExampleCleanedData/PVFulldata.csv", "../03ExampleCleanedData/PHFulldata.csv", "../03ExampleCleanedData/SFFulldata.csv", "../03ExampleCleanedData/SOFulldata.csv")
sitesdata <- lapply(pertfiles,read.csv)
names(sitesdata) <- sites
#Get the growth rate and dieback data
GrowthRates = IndivHeights_byTree(sitesdata, years, sites)
#parameter for the regressions
ctrl <- lmeControl(opt='optim')
#list of potential parameters
paramlist <- c("Ecoregion", "Dist", "Slope", "Aspect", "ElevDist", "eFFP", "MSP", "DD.5.sp")
#whether it is categorical (E - for ecoregion), linear (L), and quadratic (Q)
functype <- c("E", "L", "Q", "Q", "Q", "Q", "Q", "Q", "Q")
#number to iterate through the functype list
func_num <- 1:length(paramlist)
#Variables to look through
d_vars <- c("TotGrowth", "AmntDieback") #the two variables to look at
fam <- c("linear", "zeroinfl") #regression type
for (gstat in c(1,2)){
DepVar_name <- d_vars[gstat] #which of the two you're looking at
st_ind = 0
f <- fam[gstat]
############################## Iterating over all the sites
for (indivstdat in GrowthRates){
st_ind = st_ind + 1 #site
st = sites[st_ind]
#Get rid of ones with incomplete data
indivstdat <- indivstdat[complete.cases(indivstdat), ]
#storing the AIC values and the parameter names
AIC_list <- c()
AICnm_list <- c()
DepVarInd <- match(DepVar_name, colnames(indivstdat))
RandVar <- match("Block", colnames(indivstdat))
layer1_nums <- func_num
for(num_l1 in func_num){
num_iter = match(num_l1, layer1_nums)
layer1_nums <- layer1_nums[-num_iter] #ones left to iterate through at this level
##parameters for regression function
l1_type <- functype[num_l1] #the type
param_ind <- match(paramlist[num_l1], colnames(indivstdat)) #the index for the indep parameter
reg1 <- MultReg2(indivstdat, param_ind, DepVarInd, l1_type, RandVar, family = f)
AIC_list <- append(AIC_list, summary(reg1[[2]])$AIC)
AICnm_list <- c(AICnm_list, paramlist[num_l1])
##If there is nothing left to add
if (length(layer1_nums) == 0){
break
}
#Move to layer 2 (two variables) #####################################################################
layer2_nums = layer1_nums #so you have a list you can remove things from
for (num_l2 in layer1_nums){
num_iter = match(num_l2, layer2_nums)
layer2_nums <- layer2_nums[-num_iter]
param_n <- c(num_l1, num_l2) #the parameter numbers to use
p_fullname <- paste(paramlist[param_n], collapse="_") #get the parameter names
types <- functype[param_n] #get the parameter types
params_ind <- match(paramlist[param_n], colnames(indivstdat))
reg2 <- MultReg2(indivstdat, params_ind, DepVarInd, types, RandVar, family = f)
#Save the AIC values
AIC_list <- append(AIC_list, summary(reg2[[2]])$AIC)
AICnm_list <-append(AICnm_list, p_fullname)
##If there is nothing left to add
if (length(layer2_nums) == 0){
break
}
##Move to layer 3 (three variables)##################################################
layer3_nums = layer2_nums #so you have a list you can remove things from
for(num_l3 in layer2_nums){
#Get rid of the new parameter from further iterations
num_iter = match(num_l3, layer3_nums)
layer3_nums <- layer3_nums[-num_iter]
param_n <- c(num_l1, num_l2, num_l3) #the parameter numbers to use
p_fullname <- paste(paramlist[param_n], collapse="_") #get the parameter names
types <- functype[param_n] #get the parameter types
params_ind <- match(paramlist[param_n], colnames(indivstdat))
#run the regression
reg3 <- MultReg2(indivstdat, params_ind, DepVarInd, types, RandVar, family = f)
#Save the AIC values
AIC_list <- append(AIC_list, summary(reg3[[2]])$AIC)
AICnm_list <-append(AICnm_list, p_fullname)
##If there is nothing left to add
if (length(layer3_nums) == 0){
break
}
#Move to layer 4 (four variables)#########################################################
layer4_nums = layer3_nums #so you have a list you can remove things from
for (num_l4 in layer3_nums){
num_iter = match(num_l4, layer4_nums)
layer4_nums <- layer4_nums[-num_iter]
param_n <- c(num_l1, num_l2, num_l3, num_l4) #the parameter numbers to use
#Do the regression
p_fullname <- paste(paramlist[param_n], collapse="_") #get the parameter names
types <- functype[param_n] #get the parameter types
params_ind <- match(paramlist[param_n], colnames(indivstdat))
reg4 <- MultReg2(indivstdat, params_ind, DepVarInd, types, RandVar, family = f)
#Save the AIC values
AIC_list <- append(AIC_list, summary(reg4[[2]])$AIC)
AICnm_list <-append(AICnm_list, p_fullname)
##If there is nothing left to add
if (length(layer4_nums) == 0){
break
}
#Move to layer 5 (five variables)#########################################################
layer5_nums <- layer4_nums #so you have a list you can remove things from
for(num_l5 in layer4_nums){
num_iter <- match(num_l5, layer5_nums)
layer5_nums <- layer5_nums[-num_iter]
param_n <- c(num_l1, num_l2, num_l3, num_l4, num_l5) #the parameter numbers to use
#Do the regression
p_fullname <- paste(paramlist[param_n], collapse="_") #get the parameter names
types <- functype[param_n] #get the parameter types
params_ind <- match(paramlist[param_n], colnames(indivstdat))
reg5 <- MultReg2(indivstdat, params_ind, DepVarInd, types, RandVar, family = f)
#Save the AIC values
AIC_list <- append(AIC_list, summary(reg5[[2]])$AIC)
AICnm_list <-append(AICnm_list, p_fullname)
##If there is nothing left to add
if (length(layer5_nums) == 0){
break
}
#Move to layer 6######################################################################
layer6_nums = layer5_nums #so you have a list you can remove things from
for(num_l6 in layer5_nums){
num_iter <- match(num_l6, layer6_nums)
layer6_nums <- layer6_nums[-num_iter]
param_n <- c(num_l1, num_l2, num_l3, num_l4, num_l5, num_l6) #the parameter numbers to use
#Do the regression
p_fullname <- paste(paramlist[param_n], collapse="_") #get the parameter names
types <- functype[param_n] #get the parameter types
params_ind <- match(paramlist[param_n], colnames(indivstdat))
reg6 <- MultReg2(indivstdat, params_ind, DepVarInd, types, RandVar, family = f)
#Save the AIC values
AIC_list <- append(AIC_list, summary(reg6[[2]])$AIC)
AICnm_list <-append(AICnm_list, p_fullname)
##If there is nothing left to add
if (length(layer6_nums) == 0){
break
}
#Move to layer 7###################################################################
layer7_nums <- layer6_nums #so you have a list you can remove things from
for (num_l7 in layer6_nums){
num_iter = match(num_l7, layer7_nums)
layer7_nums <- layer7_nums[-num_iter]
param_n <- c(num_l1, num_l2, num_l3, num_l4, num_l5, num_l6, num_l7) #the parameter numbers
#Do regression
p_fullname <- paste(paramlist[param_n], collapse="_") #get the parameter names
types <- functype[param_n] #get the parameter types
params_ind <- match(paramlist[param_n], colnames(indivstdat))
reg7 <- MultReg2(indivstdat, params_ind, DepVarInd, types, RandVar, family = f)
#Save the AIC values
AIC_list <- append(AIC_list, summary(reg7[[2]])$AIC)
AICnm_list <-append(AICnm_list, p_fullname)
layer8_nums = layer7_nums
for (num_l8 in layer7_nums){
num_iter = match(num_l8, layer8_nums)
layer8_nums <- layer8_nums[-num_iter]
param_n <- c(num_l1, num_l2, num_l3, num_l4, num_l5, num_l6, num_l7, num_l8) #the parameter numbers
#Do regression
p_fullname <- paste(paramlist[param_n], collapse="_") #get the parameter names
types <- functype[param_n] #get the parameter types
params_ind <- match(paramlist[param_n], colnames(indivstdat))
reg8 <- MultReg2(indivstdat, params_ind, DepVarInd, types, RandVar, family = f)
#Save the AIC values
AIC_list <- append(AIC_list, summary(reg8[[2]])$AIC)
AICnm_list <-append(AICnm_list, p_fullname)
} #end layer 8
} #end layer 7
} #end layer 6
} #end layer 5
} #end layer 4
} #end layer 3
} #end layer 2
} #end layer 1
print(paste("Results for", st))
#To check for errors
#print(AIC_list)
#print(AICnm_list)
min_aic <- min(AIC_list)
within2_aic <- AIC_list[AIC_list < (min_aic + 2)]
within2_names <- AICnm_list[AIC_list < (min_aic + 2)]
print(within2_aic)
print(within2_names)
if(st=="PuyallupValley"){
nrows = length(within2_aic)
GR_AICmat <- matrix(NA, nrow=nrows, ncol=3)
colnames(GR_AICmat) <- c("Site", "IndepVars", "AIC")
GR_AICmat[,1] <- rep(st, nrows)
GR_AICmat[,2] <- within2_names
GR_AICmat[,3] <- within2_aic
} else {
nrows = length(within2_aic)
#Rather convoluted way to add the matrices together
oldAICmat = GR_AICmat
GR_AICmat = matrix(NA, nrow = length(oldAICmat[,1]) + nrows, ncol = length(oldAICmat[1,]))
colnames(GR_AICmat) = colnames(oldAICmat)
GR_AICmat[,1] <- append(oldAICmat[,1], rep(st, nrows))
GR_AICmat[,2] <- append(oldAICmat[,2], within2_names)
GR_AICmat[,3] <- append(oldAICmat[,3], within2_aic)
}
} #end site iteration
write.csv(GR_AICmat, print(paste("../05ProcessedDataOutputs/05BestModels/", DepVar_name, "_BestMultReg.csv", sep='')))
}
